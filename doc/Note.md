# AXF 爱鲜蜂
- 水果电商产品
- 经历比较波折，倒闭了好几次
    - 满100减99
    - 1块可以买6个进口苹果
    

## 开发
- 需求分析
- 半逆向开发模式

### 模块
- 主页面
    - 首页，home，
        - 内容展示
        - 广告
        - 首页展示效果比较复杂
    - 闪购
        - 数据级联查询
    - 我的，个人中心
        - 用户系统
    - 购物车
        - 最后开发
        - 需要商品数据和用户数据
- 二级页面
    - 订单系统
        - 下单
        - 订单流转
    - 评价系统
        - 添加评价
    - 地址管理
        - 管理收货地址
        - 地址增删改查
    - 优惠券
        - 优惠卷发放和使用条件
   

#### 下手
- 主页面
- 搭建通用架构
    - 基模板
    - 通用资源
    - 工具类
- 按模块开发

#### 模块开发
- 百分之八十都是从用户系统开发
- 其余从和不受其它模块制约的地方进行开发

#### 准备开发
- 个人中心
- 首页
- 闪购 

- 购物车需要最后实现


#### 静态资源
- jQuery
- Bootstrap
- Swiper


#### 前端技术
- 尺寸单位
    - px
    - em
        - 相对单位
        - 相对于父级元素
        - font-size
        - 默认16px
    - rem
        - 相对单位
        - 相对与根元素
        - font-size
        - 默认16px
- 将相对值设置为屏幕宽度的十分之一
    - 1rem 代表屏幕宽度百分之十
    
    
#### 首页搭建
- 提取通用部分
    - header
    - footer 控制器
- footer 根据CSS逆推
    - 把嵌套结构书写上
- 继承自基模板
    - 个性化定制自己的页面
    
#### 首页数据
- 从数据开始开发
- 从模型
- 定义模型
    - 定义字段
    
#### 闪送超市
- 布局分析
- 左右两大块
    - 左边是大类导航
    - 右边是详细信息展示
        - 右边顶部小类选择
        - 排序规则
        - 右边下部就是列表展示商品
##### 闪送超市类型
- 大类型
    - 右侧数据一定是根据左侧点击显示的
    - 左侧点击要传输参数，使用的路径参数
    - 请求视图函数可以接收参数
        - 根据接收到的参数，进行一个筛选
- 小类型
    - 小类型需要和大类型挂钩
    - 存储在大类型的一个字段中
        - 需要自己对数据进行格式转换
    - 小类型点击生效
        - 也是通过点击接收参数来的
        - 除了名字外 id也是需要传递的
    - all_type 获取所有，不根据小类型进行过滤
    
#### 我的
- 个人中心
- 用户系统
    - 用户名
    - 密码
    - 邮箱
    - 头像
    - 逻辑删除
    - 是否激活
- 用户功能封装
    - 封装是面向对象的三大功能之一
    - 设置密码
        - 注册，修改密码，忘记密码
    - 检查密码
        - 登录

#### 用户
- 数据安全
    - 哈希算法
        - sha
        - md5
    - 服务端使用sha是为了 防开发人员
    - 前端使用md5为了防 抓包人员
       
       
#### 注册，登录
- 用户系统
- 注册
    - 注册页面
    - 注册按钮
    - form 发送给服务器
    - 服务器接收数据，存储
    - 自动登录，存储之后将session存储下来
    - 扩充
        - 密码和确认密码比对
        - 客户端实现
            - onsubmit 在提交的时候，去验证
            - 需要返回一个boolean
            - 根据条件动态返回boolean
        - 用户名和邮箱预校验
            - 首先服务器得能够提供验证的接口
            - 客户端使用 ajax 和服务器进行交互
            - 去验证数据是否合法
            - 前端者获取数据，进行页面显示
        - 在submit中添加状态验证
            - 验证前端提示信息的颜色值
            - 值是  rgb(255, 0, 0)
        - 数据安全
            - 在密码存储的时候，封装了数据存储，使用sha进行一个数据安全
            - 在传输之前，验证通过之后，对数据进行一个md5
- 用户登录
    - 要和注册保持一致的数据安全策略
    - 加验证码
  
            
- 个人中心
    - 根据session进行用户信息获取
    
- 用户激活
    - 注册的时候，会向你的邮箱发送一个邮件
    - 邮件中包含验证码或者激活链接
    - 当点击链接时候，会提示账号被激活（24小时内激活）
- 代码实现
    - 注册的时候，发送邮件
    - 邮件中设计激活链接
    - 使用缓存实现
        - 我们可以在邮件中生成一个token
        - token存放在缓存中
        - token传递给客户端，通过链接的形式
        - 点击链接的时候，可以根据token找到用户
        - 修改用户信息，删除token    
- 如何发邮件
    - 邮件服务器
        - SMTP 邮件服务器
        - 发送方的用户名和密码（授权码）
        - 接收方的邮件地址
        - 内容
- 激活设计
    - 在url上使用toke
    - token存在redis或缓存中
    - token 就是key，值就是用户的唯一标识id，username
    - 找到用户，修改状态
    
- 具体实现
    - 邮件中包含token
    - 根据token可以找到用户
    - 找到用户之后就可以修改用户的任何信息
        - 可以用来激活账号
        - 可以用来重置密码
        - 找回密码
    - 用完记得扫尾
    - 敏感操作通常只能使用一次，并且还带有时效性


#### 购物车设计
- 购物车关系
    - 商品数据
    - 用户数据
    - *非必须
        - 地址级联
        - 优惠券
- 购物车体现
    - 用户和商品关系
    - 用户和商品 多对多的一个关系
    
- 购物车字段设计
    - id
    - 用户id  外键
    - 商品id  外键
    - 商品数量
    - 商品状态  选中未选中
    
- 添加到购物车
    - 购物车数据的添加
        - 商品
        - 用户
    - 用户是否登录
        - 在服务端验证
        - 向客户端发送信号
        - 自己接收信号并处理
    - 添加
        - 要判断数据库中是否存在数据
        - 存在对数量进行添加
        - 不存在对数据进行创建

#### 购物车
- 添加到购物车
    - 拿着商品id去添加
    - 判断用户状态
    - 如果用户登录，去添加
        - 判断数据是否存在，对数量进行加一
        - 如果不存在，创建数据
    - 如果用户未登录
        - 跳转登录页面
        - 发送相关信息，信号
- 在购物车中减少数据
    - 把购物车商品数据发送过去
    - 操作数量注意数据量的多少
    - 如果数量=1（或以下），直接删除数据
    - 如果大于1就是减数量
    - 等于0也没必要进行数据展示了，直接进行remove


#### bug
- 登录不上去
    - 汉字编程
        - 我们通过提交的方式将用户名和密码发送到服务器
        - 服务器中接收数据
        - 使用数据到数据库进行比对
        - 比对成功，我们就登录，将用户信息返回，切换到个人中心
        - 比对失败，重定向到登录页面
    - 调试
        - 在服务器接口处接收，打印
        - 如果是，进行下一步调试
        - 如果不是，去定位原因
        - 去打印判定结果
        
#### 数据传输
- 传输的时候，不支持的数据类型
- 可以进行数据转换，转换未支持的数据类型
- 将数组转换成 字符串，使用 # 连接
- 在服务器接收到字符串的时候，做逆向操作，使用 # 切割

#### each
- 相当于fori
- 就是对可迭代元素进行遍历


#### 下单
- 在点击下单的时候
- 应该将所有选中的商品，传递给服务器
- 服务器接收到选中的商品，要生成一个订单
- 订单包含
    - 商品列表（复数）
    - 购买的用户
    - 地址
    - 订单号
    - 下单时间
    - 订单状态
- 订单生成之后
    - 付款
    - 调用支付平台
    - 之后的页面都是平台页面
        - 做不了
        - 需要商户账号（支付宝）
        - 企业营业执照
    - python做比较麻烦
        - 支付案例官方都会提供代码
        - 没有对python提供支持
            - java
            - php
            - .net
    - github
        - 有民间的高手实现了
        - 就是把支付宝数据处理策略，使用python实现了避免
       
       
#### 购物车实现
- 是为了做商品和用户的购买的关系
    - 前提有商品系统和用户系统
- 商品用户系统和用户系统
    - 商品和用户是一个多对多的关系
    - ManyTomyField，关系表自动生成，定制复杂，不能直接操作关系表
        - 通过多个外键实现
    - 购物车就是用户和商品多对多
        - 自己创建一个购物车表
        - 内部使用两个外键来和用户表还有商品表建立关联
        - 还可以添加自己的字段
- 购物车逻辑
    - 添加到购物车
        - 在添加的时候，要判断有没有此条关系数据
        - 如果存在，数量加一
        - 如果不存在，直接创建
    - 修改购物车数据
        - 添加就是数量加一
        - 减少需要注意数量
            - 如果数量为一，直接删除该条数据
            - 如果数量大于一，数据减一   
            
- 购物车选中状态变更
    - 当我们点击某一个商品是否选中的时候
    - 根据商品id找到购物车中的商品，修改状态
    - 全选
        - 如果有一个未选中，全选则为未选中
        - 当所有商品都是选中，全选按钮应该是选中的
        - 当点击状态切换的时候，如果我们变成未选中，全选按钮一定变成未选中
        - 我点击状态变成选中的，要判断全选按钮是否要被选中
    - 价钱
        - 只要商品信息变化，就需要重新计算价钱
        - 价钱的计算，前后端都能实现
        - 提交的时候一定由服务器来算
- 下单
    - 订单生成流程
    - 就是将购物车中的数据转换成订单的数据
    - 购物车表数据和订单数据转换的时候一张表需要转换成两张表
        - 订单表
        - 订单商品表
    - 下单流程
        - 要生成一个订单
        - 生成订单商品
        - 订单商品数据是从购物车中的选中数据来的
        - 购物车数据删除
- 订单信息
    - 根据订单标识，将订单展示出来   

#### 项目部署
- 在django开发中，使用的是开发者服务器
    - 不适合做生产环境服务器
    - 性能低
- nginx + uwsgi 



     

 
#### 坑点
- ifequal 
    - 判断相等
    - 类型和值都会判断
    - 视图函数中，接收到的参数都是会转换成字符串的
- 前端bug
    - 高度塌陷
    - 一个容器的内部的所有元素都是浮动的
    - 容器的高度为 0 
- 重定向
    - 这个是浏览器的行为
    - ajax不具备重定向能力
- 运算
    - 出现了小数点后 n位
    - 原因是数据运算的底层并不是精确运算
    - 编程语言通病
- 文件数量限制
    - xxx  65535
    - xxx/a/yyy
    - xxx/b/yyy
    - xxx/aa/yyy

    
#### 快捷键
- 重构
    - shift + f6
    - 修改名字，会将引用此名字的地方重新修改


#### 前端
- VUE